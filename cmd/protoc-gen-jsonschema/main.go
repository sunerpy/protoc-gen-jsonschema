package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/sunerpy/protoc-gen-jsonschema"
	jsonschemapb "github.com/sunerpy/protoc-gen-jsonschema/mcp/jsonschema"
)

const version = "1.0.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("protoc-gen-jsonschema %v\n", version)
		return
	}

	// Read CodeGeneratorRequest from stdin
	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		panic(fmt.Sprintf("failed to read input: %v", err))
	}

	var req pluginpb.CodeGeneratorRequest
	if err := proto.Unmarshal(input, &req); err != nil {
		panic(fmt.Sprintf("failed to unmarshal request: %v", err))
	}

	// Parse parameters
	params := parseParameters(req.GetParameter())

	// Create plugin options
	opts := protogen.Options{}
	plugin, err := opts.New(&req)
	if err != nil {
		panic(fmt.Sprintf("failed to create plugin: %v", err))
	}

	// Declare supported features
	plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

	// Generate schemas for all files
	if err := generate(plugin, params); err != nil {
		plugin.Error(err)
	}

	// Write response to stdout
	resp := plugin.Response()
	output, err := proto.Marshal(resp)
	if err != nil {
		panic(fmt.Sprintf("failed to marshal response: %v", err))
	}

	if _, err := os.Stdout.Write(output); err != nil {
		panic(fmt.Sprintf("failed to write output: %v", err))
	}
}

type genParams struct {
	format        string // "json" or "go_const"
	suffix        string // file suffix for go_const format
	preserveOrder bool   // preserve field order from proto definition
	schemaStruct  bool   // generate jsonschema.Schema struct literal (map[string]interface{})
	googleSchema  bool   // generate Google jsonschema.Schema struct literal (*jsonschema.Schema)
}

func parseParameters(param string) genParams {
	params := genParams{
		format: "json",
		suffix: "_jsonschema",
	}

	if param == "" {
		return params
	}

	for _, p := range strings.Split(param, ",") {
		parts := strings.SplitN(p, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "format":
			params.format = value
		case "suffix":
			params.suffix = value
		case "preserve_order":
			params.preserveOrder = value == "true"
		case "schema_struct":
			params.schemaStruct = value == "true"
		case "google_schema":
			params.googleSchema = value == "true"
		}
	}

	return params
}

func generate(plugin *protogen.Plugin, params genParams) error {
	gen := jsonschema.NewGenerator()
	gen.SetPreserveOrder(params.preserveOrder)

	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		// Generate based on format parameter
		switch params.format {
		case "go_const":
			if err := generateGoConstFile(plugin, gen, file, params); err != nil {
				return fmt.Errorf("failed to generate go const for %s: %w", file.Desc.Path(), err)
			}
		case "json":
			if err := generateSchemaFile(plugin, gen, file); err != nil {
				return fmt.Errorf("failed to generate schema for %s: %w", file.Desc.Path(), err)
			}
		default:
			return fmt.Errorf("unknown format: %s", params.format)
		}
	}

	return nil
}

func generateGoConstFile(plugin *protogen.Plugin, gen *jsonschema.Generator, file *protogen.File, params genParams) error {
	if len(file.Messages) == 0 {
		return nil
	}

	// Create output filename: user.proto -> user_jsonschema.pb.go
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + params.suffix + ".pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// File header
	g.P("// Code generated by protoc-gen-jsonschema. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	if params.schemaStruct || params.googleSchema {
		g.P("import (")
		g.P("\t\"encoding/json\"")
		g.P()
		if params.schemaStruct {
			g.P("\tlocalschema \"github.com/sunerpy/protoc-gen-jsonschema\"")
		}
		if params.googleSchema {
			g.P("\t\"github.com/google/jsonschema-go/jsonschema\"")
		}
		g.P(")")
	} else {
		g.P("import \"encoding/json\"")
	}
	g.P()

	// Generate methods and constants for each message
	for _, message := range file.Messages {
		if shouldGenerateSchema(message) {
			if err := generateMessageConst(g, gen, message, params.schemaStruct, params.googleSchema); err != nil {
				return fmt.Errorf("failed to generate const for %s: %w", message.Desc.FullName(), err)
			}
		}
	}

	return nil
}

func generateMessageConst(g *protogen.GeneratedFile, gen *jsonschema.Generator, message *protogen.Message, schemaStruct bool, googleSchema bool) error {
	var jsonStr string

	// Generate JSON Schema based on preserveOrder setting
	if gen.IsPreserveOrder() {
		orderedSchema, err := gen.GenerateOrderedSchema(message.Desc)
		if err != nil {
			return err
		}
		if orderedSchema == nil {
			return nil
		}
		jsonBytes, err := json.Marshal(orderedSchema)
		if err != nil {
			return fmt.Errorf("failed to marshal ordered schema: %w", err)
		}
		jsonStr = string(jsonBytes)
	} else {
		schema, err := gen.GenerateSchema(message.Desc)
		if err != nil {
			return err
		}
		if schema == nil {
			return nil
		}
		jsonBytes, err := json.Marshal(schema)
		if err != nil {
			return fmt.Errorf("failed to marshal schema: %w", err)
		}
		jsonStr = string(jsonBytes)
	}

	// Constant name: UserRequest -> userRequestSchemaJSON
	constName := toLowerCamelCase(message.GoIdent.GoName) + "SchemaJSON"
	typeName := message.GoIdent.GoName

	// Generate GetJSONSchema method
	g.P("// GetJSONSchema returns the JSON Schema for ", typeName)
	g.P("// Performance: ~0.29 ns/op, zero memory allocation")
	g.P("func (*", typeName, ") GetJSONSchema() string {")
	g.P("\treturn ", constName)
	g.P("}")
	g.P()

	// Generate GetJSONSchemaBytes method
	g.P("// GetJSONSchemaBytes returns the JSON Schema as a byte array")
	g.P("// Useful for HTTP responses")
	g.P("// Performance: ~0.34 ns/op, zero memory allocation")
	g.P("func (*", typeName, ") GetJSONSchemaBytes() []byte {")
	g.P("\treturn []byte(", constName, ")")
	g.P("}")
	g.P()

	// Generate GetJSONSchemaRawMessage method
	g.P("// GetJSONSchemaRawMessage returns the JSON Schema as json.RawMessage")
	g.P("// Useful for JSON encoding without additional escaping")
	g.P("// Performance: ~0.34 ns/op, zero memory allocation")
	g.P("func (*", typeName, ") GetJSONSchemaRawMessage() json.RawMessage {")
	g.P("\treturn json.RawMessage(", constName, ")")
	g.P("}")
	g.P()

	// Generate constant
	g.P("const ", constName, " = `", jsonStr, "`")
	g.P()

	// Generate localschema.Schema struct literal if requested
	if schemaStruct {
		varName := toLowerCamelCase(message.GoIdent.GoName) + "Schema"

		// Parse the JSON to get the schema structure
		var schemaMap map[string]interface{}
		if err := json.Unmarshal([]byte(jsonStr), &schemaMap); err != nil {
			return fmt.Errorf("failed to unmarshal schema for code generation: %w", err)
		}

		g.P("// ", varName, " is the compile-time JSON Schema for ", typeName)
		g.P("// This is a Go struct literal, requiring zero runtime parsing")
		g.P("// Performance: Direct struct access, zero initialization overhead, zero parsing cost")
		g.P("var ", varName, " = ", generateSchemaLiteral(schemaMap, 0))
		g.P()

		// Generate GetSchema method
		g.P("// GetSchema returns the compile-time JSON Schema struct for ", typeName)
		g.P("// Unlike GetJSONSchema() which returns a string that needs json.Unmarshal,")
		g.P("// this method returns a pre-built struct with zero parsing overhead")
		g.P("// Performance: Direct variable access, zero allocation, zero parsing")
		g.P("func (*", typeName, ") GetSchema() localschema.Schema {")
		g.P("\treturn ", varName)
		g.P("}")
		g.P()
	}

	// Generate Google jsonschema.Schema struct literal if requested
	if googleSchema {
		varName := toLowerCamelCase(message.GoIdent.GoName) + "GoogleSchema"

		// Parse the JSON to get the schema structure
		var schemaMap map[string]interface{}
		if err := json.Unmarshal([]byte(jsonStr), &schemaMap); err != nil {
			return fmt.Errorf("failed to unmarshal schema for code generation: %w", err)
		}

		g.P("// ", varName, " is the compile-time Google JSON Schema for ", typeName)
		g.P("// This is a Google jsonschema.Schema struct literal, requiring zero runtime parsing")
		g.P("// Can be used directly with github.com/google/jsonschema-go for validation")
		g.P("// Performance: Direct struct access, zero initialization overhead, zero parsing cost")
		g.P("var ", varName, " = ", generateGoogleSchemaLiteral(schemaMap, 0))
		g.P()

		// Generate GetGoogleSchema method
		g.P("// GetGoogleSchema returns the compile-time Google JSON Schema struct for ", typeName)
		g.P("// Unlike GetJSONSchema() which returns a string that needs json.Unmarshal,")
		g.P("// this method returns a pre-built Google jsonschema.Schema struct with zero parsing overhead")
		g.P("// Can be used directly for validation with github.com/google/jsonschema-go")
		g.P("// Performance: Direct variable access, zero allocation, zero parsing")
		g.P("func (*", typeName, ") GetGoogleSchema() *jsonschema.Schema {")
		g.P("\treturn ", varName)
		g.P("}")
		g.P()
	}

	return nil
}

// generateSchemaLiteral converts a map[string]interface{} to Go code literal
func generateSchemaLiteral(m map[string]interface{}, indent int) string {
	if len(m) == 0 {
		return "jsonschema.Schema{}"
	}

	var sb strings.Builder
	sb.WriteString("jsonschema.Schema{\n")

	// Sort keys for consistent output
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}

	indentStr := strings.Repeat("\t", indent+1)
	for i, key := range keys {
		if i > 0 {
			sb.WriteString(",\n")
		}
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("%q: ", key))
		sb.WriteString(generateValueLiteral(m[key], indent+1))
	}

	sb.WriteString(",\n")
	sb.WriteString(strings.Repeat("\t", indent))
	sb.WriteString("}")

	return sb.String()
}

// generateValueLiteral converts an interface{} value to Go code literal
func generateValueLiteral(v interface{}, indent int) string {
	switch val := v.(type) {
	case string:
		return fmt.Sprintf("%q", val)
	case int, int32, int64:
		return fmt.Sprintf("%d", val)
	case float32, float64:
		return fmt.Sprintf("%v", val)
	case bool:
		return fmt.Sprintf("%t", val)
	case []interface{}:
		if len(val) == 0 {
			return "[]interface{}{}"
		}
		var sb strings.Builder
		sb.WriteString("[]interface{}{\n")
		indentStr := strings.Repeat("\t", indent+1)
		for i, item := range val {
			if i > 0 {
				sb.WriteString(",\n")
			}
			sb.WriteString(indentStr)
			sb.WriteString(generateValueLiteral(item, indent+1))
		}
		sb.WriteString(",\n")
		sb.WriteString(strings.Repeat("\t", indent))
		sb.WriteString("}")
		return sb.String()
	case map[string]interface{}:
		return generateSchemaLiteral(val, indent)
	default:
		return fmt.Sprintf("%#v", val)
	}
}

// generateGoogleSchemaLiteral converts a map[string]interface{} to Google jsonschema.Schema literal
func generateGoogleSchemaLiteral(m map[string]interface{}, indent int) string {
	var sb strings.Builder
	sb.WriteString("&jsonschema.Schema{\n")
	indentStr := strings.Repeat("\t", indent+1)

	// Type
	if typeVal, ok := m["type"].(string); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Type: %q,\n", typeVal))
	}

	// Title
	if title, ok := m["title"].(string); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Title: %q,\n", title))
	}

	// Description
	if desc, ok := m["description"].(string); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Description: %q,\n", desc))
	}

	// Format
	if format, ok := m["format"].(string); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Format: %q,\n", format))
	}

	// Pattern
	if pattern, ok := m["pattern"].(string); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Pattern: %q,\n", pattern))
	}

	// MinLength
	if minLen, ok := m["minLength"].(float64); ok {
		val := int(minLen)
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("MinLength: &[]int{%d}[0],\n", val))
	}

	// MaxLength
	if maxLen, ok := m["maxLength"].(float64); ok {
		val := int(maxLen)
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("MaxLength: &[]int{%d}[0],\n", val))
	}

	// Minimum
	if min, ok := m["minimum"].(float64); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Minimum: &[]float64{%v}[0],\n", min))
	}

	// Maximum
	if max, ok := m["maximum"].(float64); ok {
		sb.WriteString(indentStr)
		sb.WriteString(fmt.Sprintf("Maximum: &[]float64{%v}[0],\n", max))
	}

	// Enum
	if enum, ok := m["enum"].([]interface{}); ok && len(enum) > 0 {
		sb.WriteString(indentStr)
		sb.WriteString("Enum: []any{")
		for i, e := range enum {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(fmt.Sprintf("%q", e))
		}
		sb.WriteString("},\n")
	}

	// Properties
	if props, ok := m["properties"].(map[string]interface{}); ok && len(props) > 0 {
		sb.WriteString(indentStr)
		sb.WriteString("Properties: map[string]*jsonschema.Schema{\n")
		for key, val := range props {
			if propMap, ok := val.(map[string]interface{}); ok {
				sb.WriteString(strings.Repeat("\t", indent+2))
				sb.WriteString(fmt.Sprintf("%q: ", key))
				sb.WriteString(generateGoogleSchemaLiteral(propMap, indent+2))
				sb.WriteString(",\n")
			}
		}
		sb.WriteString(indentStr)
		sb.WriteString("},\n")
	}

	// Required
	if required, ok := m["required"].([]interface{}); ok && len(required) > 0 {
		sb.WriteString(indentStr)
		sb.WriteString("Required: []string{")
		for i, r := range required {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(fmt.Sprintf("%q", r))
		}
		sb.WriteString("},\n")
	}

	// Items (for arrays)
	if items, ok := m["items"].(map[string]interface{}); ok {
		sb.WriteString(indentStr)
		sb.WriteString("Items: ")
		sb.WriteString(generateGoogleSchemaLiteral(items, indent+1))
		sb.WriteString(",\n")
	}

	sb.WriteString(strings.Repeat("\t", indent))
	sb.WriteString("}")

	return sb.String()
}

func toLowerCamelCase(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func generateSchemaFile(plugin *protogen.Plugin, gen *jsonschema.Generator, file *protogen.File) error {
	// Create output filename: user.proto -> user.schema.json
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + ".schema.json"
	g := plugin.NewGeneratedFile(filename, "")

	schemas := make(map[string]interface{})

	// Generate schema for each message in the file
	for _, message := range file.Messages {
		if shouldGenerateSchema(message) {
			schema, err := gen.GenerateSchema(message.Desc)
			if err != nil {
				return fmt.Errorf("failed to generate schema for %s: %w", message.Desc.FullName(), err)
			}

			if schema != nil {
				// Use full message name as key
				schemas[string(message.Desc.FullName())] = schema
			}
		}
	}

	// Write schemas to file
	if len(schemas) > 0 {
		data, err := json.MarshalIndent(schemas, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal schemas: %w", err)
		}

		g.P(string(data))
	}

	return nil
}

func shouldGenerateSchema(message *protogen.Message) bool {
	opts := message.Desc.Options()
	if opts == nil {
		return true
	}

	if proto.HasExtension(opts, jsonschemapb.E_GenerateSchema) {
		return proto.GetExtension(opts, jsonschemapb.E_GenerateSchema).(bool)
	}

	return true
}
