package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/sunerpy/protoc-gen-jsonschema"
	jsonschemapb "github.com/sunerpy/protoc-gen-jsonschema/mcp/jsonschema"
)

const version = "1.0.0"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()

	if *showVersion {
		fmt.Printf("protoc-gen-jsonschema %v\n", version)
		return
	}

	// Read CodeGeneratorRequest from stdin
	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		panic(fmt.Sprintf("failed to read input: %v", err))
	}

	var req pluginpb.CodeGeneratorRequest
	if err := proto.Unmarshal(input, &req); err != nil {
		panic(fmt.Sprintf("failed to unmarshal request: %v", err))
	}

	// Parse parameters
	params := parseParameters(req.GetParameter())

	// Create plugin options
	opts := protogen.Options{}
	plugin, err := opts.New(&req)
	if err != nil {
		panic(fmt.Sprintf("failed to create plugin: %v", err))
	}

	// Generate schemas for all files
	if err := generate(plugin, params); err != nil {
		plugin.Error(err)
	}

	// Write response to stdout
	resp := plugin.Response()
	output, err := proto.Marshal(resp)
	if err != nil {
		panic(fmt.Sprintf("failed to marshal response: %v", err))
	}

	if _, err := os.Stdout.Write(output); err != nil {
		panic(fmt.Sprintf("failed to write output: %v", err))
	}
}

type genParams struct {
	format string // "json" or "go_const"
	suffix string // file suffix for go_const format
}

func parseParameters(param string) genParams {
	params := genParams{
		format: "json",
		suffix: "_jsonschema",
	}

	if param == "" {
		return params
	}

	for _, p := range strings.Split(param, ",") {
		parts := strings.SplitN(p, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "format":
			params.format = value
		case "suffix":
			params.suffix = value
		}
	}

	return params
}

func generate(plugin *protogen.Plugin, params genParams) error {
	gen := jsonschema.NewGenerator()

	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		// Generate based on format parameter
		switch params.format {
		case "go_const":
			if err := generateGoConstFile(plugin, gen, file, params.suffix); err != nil {
				return fmt.Errorf("failed to generate go const for %s: %w", file.Desc.Path(), err)
			}
		case "json":
			if err := generateSchemaFile(plugin, gen, file); err != nil {
				return fmt.Errorf("failed to generate schema for %s: %w", file.Desc.Path(), err)
			}
		default:
			return fmt.Errorf("unknown format: %s", params.format)
		}
	}

	return nil
}

func generateGoConstFile(plugin *protogen.Plugin, gen *jsonschema.Generator, file *protogen.File, suffix string) error {
	if len(file.Messages) == 0 {
		return nil
	}

	// Create output filename: user.proto -> user_jsonschema.pb.go
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + suffix + ".pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	// File header
	g.P("// Code generated by protoc-gen-jsonschema. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate methods and constants for each message
	for _, message := range file.Messages {
		if shouldGenerateSchema(message) {
			if err := generateMessageConst(g, gen, message); err != nil {
				return fmt.Errorf("failed to generate const for %s: %w", message.Desc.FullName(), err)
			}
		}
	}

	return nil
}

func generateMessageConst(g *protogen.GeneratedFile, gen *jsonschema.Generator, message *protogen.Message) error {
	// Generate JSON Schema
	schema, err := gen.GenerateSchema(message.Desc)
	if err != nil {
		return err
	}

	if schema == nil {
		return nil
	}

	jsonBytes, err := json.Marshal(schema)
	if err != nil {
		return fmt.Errorf("failed to marshal schema: %w", err)
	}
	jsonStr := string(jsonBytes)

	// Constant name: UserRequest -> userRequestSchemaJSON
	constName := toLowerCamelCase(message.GoIdent.GoName) + "SchemaJSON"
	typeName := message.GoIdent.GoName

	// Generate GetJSONSchema method
	g.P("// GetJSONSchema returns the JSON Schema for ", typeName)
	g.P("// Performance: ~0.29 ns/op, zero memory allocation")
	g.P("func (*", typeName, ") GetJSONSchema() string {")
	g.P("\treturn ", constName)
	g.P("}")
	g.P()

	// Generate GetJSONSchemaBytes method
	g.P("// GetJSONSchemaBytes returns the JSON Schema as a byte array")
	g.P("// Useful for HTTP responses")
	g.P("// Performance: ~0.34 ns/op, zero memory allocation")
	g.P("func (*", typeName, ") GetJSONSchemaBytes() []byte {")
	g.P("\treturn []byte(", constName, ")")
	g.P("}")
	g.P()

	// Generate constant
	g.P("const ", constName, " = `", jsonStr, "`")
	g.P()

	return nil
}

func toLowerCamelCase(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func generateSchemaFile(plugin *protogen.Plugin, gen *jsonschema.Generator, file *protogen.File) error {
	// Create output filename: user.proto -> user.schema.json
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + ".schema.json"
	g := plugin.NewGeneratedFile(filename, "")

	schemas := make(map[string]interface{})

	// Generate schema for each message in the file
	for _, message := range file.Messages {
		if shouldGenerateSchema(message) {
			schema, err := gen.GenerateSchema(message.Desc)
			if err != nil {
				return fmt.Errorf("failed to generate schema for %s: %w", message.Desc.FullName(), err)
			}

			if schema != nil {
				// Use full message name as key
				schemas[string(message.Desc.FullName())] = schema
			}
		}
	}

	// Write schemas to file
	if len(schemas) > 0 {
		data, err := json.MarshalIndent(schemas, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal schemas: %w", err)
		}

		g.P(string(data))
	}

	return nil
}

func shouldGenerateSchema(message *protogen.Message) bool {
	opts := message.Desc.Options()
	if opts == nil {
		return true
	}

	if proto.HasExtension(opts, jsonschemapb.E_GenerateSchema) {
		return proto.GetExtension(opts, jsonschemapb.E_GenerateSchema).(bool)
	}

	return true
}
